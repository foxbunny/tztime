// Generated by CoffeeScript 1.6.3
/*
@author Your Name <email@example.com>
@license LICENSE
*/

var define;

define = (function(root) {
  if (typeof root.define === 'function' && root.define.amd) {
    return root.define;
  } else {
    if (typeof module === 'object' && module.exports) {
      return function(factory) {
        return module.exports = factory();
      };
    } else {
      return function(factory) {
        return root.TzTime = factory();
      };
    }
  }
})(this);

define(function(require) {
  var DAY_MS, TzTime;
  TzTime = (function() {
    var D, METHODS, NON_TZ_AWARE_GETTERS, NON_TZ_AWARE_SETTERS, TZ_AWARE_METHODS, m, property, staticProperty, wrap, wrapReturn, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref;

    property = function(name, descriptor) {
      return Object.defineProperty(TzTime.prototype, name, descriptor);
    };

    staticProperty = function(name, descriptor) {
      return Object.defineProperty(TzTime, name, descriptor);
    };

    wrap = function(name) {
      return TzTime.prototype[name] = function() {
        var _ref;
        return (_ref = this.__datetime__)[name].apply(_ref, arguments);
      };
    };

    wrapReturn = function(name) {
      return TzTime.prototype[name] = function() {
        var _ref;
        (_ref = this.__datetime__)[name].apply(_ref, arguments);
        return this;
      };
    };

    METHODS = ['FullYear', 'Month', 'Date', 'Day', 'Hours', 'Minutes', 'Seconds', 'Milliseconds'];

    TZ_AWARE_METHODS = ['FullYear', 'Month', 'Date', 'Day', 'Hours', 'Minutes'];

    NON_TZ_AWARE_GETTERS = ['Seconds', 'Milliseconds'];

    NON_TZ_AWARE_SETTERS = ['Minutes', 'Seconds', 'Milliseconds'];

    function TzTime(yr, mo, dy, hr, mi, se, ms, tz) {
      var instance, t;
      if (hr == null) {
        hr = 0;
      }
      if (mi == null) {
        mi = 0;
      }
      if (se == null) {
        se = 0;
      }
      if (ms == null) {
        ms = 0;
      }
      if (tz == null) {
        tz = null;
      }
      if (!(this instanceof TzTime)) {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(TzTime, arguments, function(){});
      }
      switch (arguments.length) {
        case 0:
          instance = new Date();
          break;
        case 1:
          if (yr instanceof TzTime) {
            instance = new Date(yr.getTime());
            this.__tz__ = yr.timezone;
          } else if (yr instanceof Date) {
            instance = new Date(yr.getTime());
          } else {
            instance = new Date(yr);
          }
          break;
        case 2:
          throw new Error("Not implemented yet");
          break;
        case 8:
          t = Date.UTC(yr, mo, dy, hr, mi, se, ms);
          t -= tz * 60 * 1000;
          instance = new Date(t);
          this.__tz__ = tz;
          break;
        default:
          instance = new Date(yr, mo, dy, hr, mi, se, ms);
      }
      this.__tz__ || (this.__tz__ = -instance.getTimezoneOffset());
      this.__datetime__ = instance;
      this.constructor = TzTime;
    }

    D = function() {};

    D.prototype = Date.prototype;

    TzTime.prototype = new D();

    property('timezone', {
      get: function() {
        return -this.getTimezoneOffset();
      },
      set: function(v) {
        return this.setTimezoneOffset(-v);
      }
    });

    property('year', {
      get: function() {
        return this.getFullYear();
      },
      set: function(v) {
        return this.setFullYear(v);
      }
    });

    property('month', {
      get: function() {
        return this.getMonth();
      },
      set: function(v) {
        return this.setMonth(v);
      }
    });

    property('date', {
      get: function() {
        return this.getDate();
      },
      set: function(v) {
        return this.setDate(v);
      }
    });

    property('day', {
      get: function() {
        return this.getDay();
      },
      set: function() {
        throw new TypeError("Cannot assign to day");
      }
    });

    property('hours', {
      get: function() {
        return this.getHours();
      },
      set: function(v) {
        return this.setHours(v);
      }
    });

    property('minutes', {
      get: function() {
        return this.getMinutes();
      },
      set: function(v) {
        return this.setMinutes(v);
      }
    });

    property('seconds', {
      get: function() {
        return this.getSeconds();
      },
      set: function(v) {
        return this.setSeconds(v);
      }
    });

    property('milliseconds', {
      get: function() {
        return this.getMilliseconds();
      },
      set: function(v) {
        return this.setMilliseconds(v);
      }
    });

    property('utcYear', {
      get: function() {
        return this.getUTCFullYear();
      },
      set: function(v) {
        return this.setUTCFullYear(v);
      }
    });

    property('utcMonth', {
      get: function() {
        return this.getUTCMonth();
      },
      set: function(v) {
        return this.setUTCMonth(v);
      }
    });

    property('utcDate', {
      get: function() {
        return this.getUTCDate();
      },
      set: function(v) {
        return this.setUTCDate(v);
      }
    });

    property('utcDay', {
      get: function() {
        return this.getUTCDay();
      },
      set: function() {
        throw new TypeError("Cannot assign to utcDay");
      }
    });

    property('utcHours', {
      get: function() {
        return this.getUTCHours();
      },
      set: function(v) {
        return this.setUTCHours(v);
      }
    });

    property('utcMinutes', {
      get: function() {
        return this.getUTCMinutes();
      },
      set: function(v) {
        return this.setUTCMinutes(v);
      }
    });

    property('utcSeconds', {
      get: function() {
        return this.getUTCSeconds();
      },
      set: function(v) {
        return this.setUTCSeconds(v);
      }
    });

    property('utcMilliseconds', {
      get: function() {
        return this.getUTCMilliseconds();
      },
      set: function(v) {
        return this.setUTCMilliseconds(v);
      }
    });

    TzTime.prototype.getTimezoneOffset = function() {
      return -this.__tz__;
    };

    TzTime.prototype.setTimezoneOffset = function(v) {
      var delta;
      v = parseInt(v);
      if (isNaN(v)) {
        throw new TypeError("Time zone offset must be an integer.");
      }
      if ((-720 > v && v > 720)) {
        throw new TypeError("Time zone offset out of bounds.");
      }
      v = -v;
      delta = v - this.__tz__;
      this.__tz__ = v;
      this.setUTCMinutes(this.getUTCMinutes() - delta);
      return this;
    };

    _ref = ['toDateString', 'toISOString', 'toJSON', 'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString', 'toString', 'toTimeString', 'toUTCString', 'valueOf', 'getTime'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      wrap(m);
    }

    wrapReturn('setTime');

    if (m !== 'Day') {
      for (_j = 0, _len1 = METHODS.length; _j < _len1; _j++) {
        m = METHODS[_j];
        wrapReturn('setUTC' + m);
      }
    }

    for (_k = 0, _len2 = NON_TZ_AWARE_SETTERS.length; _k < _len2; _k++) {
      m = NON_TZ_AWARE_SETTERS[_k];
      wrapReturn('set' + m);
    }

    for (_l = 0, _len3 = METHODS.length; _l < _len3; _l++) {
      m = METHODS[_l];
      wrap('getUTC' + m);
    }

    for (_m = 0, _len4 = NON_TZ_AWARE_GETTERS.length; _m < _len4; _m++) {
      m = NON_TZ_AWARE_GETTERS[_m];
      wrap('get' + m);
    }

    (function(proto) {
      var method, _len5, _n;
      for (_n = 0, _len5 = TZ_AWARE_METHODS.length; _n < _len5; _n++) {
        method = TZ_AWARE_METHODS[_n];
        if (!(method === 'Day' || method === 'Minutes')) {
          proto['set' + method] = (function(method) {
            return function() {
              var delta, time;
              this['setUTC' + method].apply(this, arguments);
              time = this.getTime();
              delta = time - this.timezone * 60 * 1000;
              this.setTime(delta);
              return this;
            };
          })(method);
        }
        proto['get' + method] = (function(method) {
          return function() {
            var d;
            d = new Date(this.getTime() + this.timezone * 60 * 1000);
            return d['getUTC' + method]();
          };
        })(method);
      }
    })(TzTime.prototype);

    TzTime.prototype.toFormat = function(format) {
      var r, token,
        _this = this;
      if (format == null) {
        format = TzTime.DEFAULT_FORMAT;
      }
      for (token in TzTime.FORMAT_TOKENS) {
        r = new RegExp(token, 'g');
        format = format.replace(r, function() {
          return TzTime.FORMAT_TOKENS[token].call(_this);
        });
      }
      return format;
    };

    TzTime.prototype.strftime = TzTime.prototype.toFormat;

    TzTime.prototype.resetTime = function() {
      this.hours = this.minutes = this.seconds = this.milliseconds = 0;
      return this;
    };

    staticProperty('platformZone', {
      get: function() {
        return -(new Date().getTimezoneOffset());
      },
      set: function() {
        throw new TypeError("Cannot assign to platformZone");
      }
    });

    TzTime.parse = function(s, format) {
      var converters, fn, idx, key, matches, meta, parseTokenRe, parseTokens, rxp, schr, _len5, _len6, _n, _o, _ref1;
      if (format == null) {
        format = TzTime.DEFAULT_FORMAT;
      }
      rxp = format.replace(/\\/, '\\\\');
      _ref1 = TzTime.REGEXP_CHARS;
      for (_n = 0, _len5 = _ref1.length; _n < _len5; _n++) {
        schr = _ref1[_n];
        rxp = rxp.replace(new RegExp('\\' + schr, 'g'), "\\" + schr);
      }
      parseTokens = (function() {
        var _results;
        _results = [];
        for (key in TzTime.PARSE_RECIPES) {
          _results.push(key);
        }
        return _results;
      })();
      parseTokenRe = new RegExp("(" + (parseTokens.join('|')) + ")", "g");
      converters = [];
      rxp = rxp.replace(parseTokenRe, function(m, token) {
        var fn, re, _ref2;
        _ref2 = TzTime.PARSE_RECIPES[token](), re = _ref2.re, fn = _ref2.fn;
        converters.push(fn);
        return "(" + re + ")";
      });
      rxp = new RegExp("^" + rxp + "$", "i");
      matches = s.match(rxp);
      if (!matches) {
        return null;
      }
      matches.shift();
      meta = {
        year: 0,
        month: 0,
        date: 0,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        timeAdjust: false,
        timezone: null
      };
      for (idx = _o = 0, _len6 = converters.length; _o < _len6; idx = ++_o) {
        fn = converters[idx];
        fn(matches[idx], meta);
      }
      return new TzTime(meta.year, meta.month, meta.date, (meta.timeAdjust ? hour24(meta.hour) : meta.hour), meta.minute, meta.second, meta.millisecond, meta.timezone);
    };

    TzTime.strptime = TzTime.parse;

    return TzTime;

  })();
  TzTime.DAY_MS = DAY_MS = 86400000;
  TzTime.REGEXP_CHARS = '^$[]().{}+*?|'.split('');
  TzTime.MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  TzTime.MNTH = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  TzTime.DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  TzTime.DY = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  TzTime.AM = 'a.m.';
  TzTime.PM = 'p.m.';
  TzTime.WEEK_START = 0;
  TzTime.FORMAT_TOKENS = {
    '%a': function() {
      return TzTime.DY[this.day];
    },
    '%A': function() {
      return TzTime.DAYS[this.day];
    },
    '%b': function() {
      return TzTime.MNTH[this.month];
    },
    '%B': function() {
      return TzTime.MONTHS[this.month];
    },
    '%c': function() {
      return this.toLocaleString();
    },
    '%d': function() {
      return TzTime.utils.pad(this.date, 2);
    },
    '%D': function() {
      return "" + this.date;
    },
    '%f': function() {
      var fs;
      fs = Math.round((this.seconds + this.milliseconds / 1000) * 100) / 100;
      return TzTime.utils.pad(fs, 2, 2);
    },
    '%H': function() {
      return TzTime.utils.pad(this.hours, 2);
    },
    '%i': function() {
      return TzTime.utils.cycle(this.hours, 12);
    },
    '%I': function() {
      return TzTime.utils.pad(TzTime.utils.cycle(this.hours, 12), 2);
    },
    '%j': function() {
      var firstOfYear;
      firstOfYear = new TzTime(this.year, 0, 1);
      return TzTime.utils.pad(Math.ceil((this - firstOfYear) / TzTime.DAY_MS), 3);
    },
    '%m': function() {
      return TzTime.utils.pad(this.month + 1, 2);
    },
    '%M': function() {
      return TzTime.utils.pad(this.minutes, 2);
    },
    '%n': function() {
      return "" + (this.month + 1);
    },
    '%N': function() {
      return "" + this.minutes;
    },
    '%p': function() {
      return (function(h) {
        if ((0 <= h && h < 12)) {
          return TzTime.AM;
        } else {
          return TzTime.PM;
        }
      })(this.hours);
    },
    '%s': function() {
      return "" + this.seconds;
    },
    '%S': function() {
      return TzTime.utils.pad(this.seconds, 2);
    },
    '%r': function() {
      return "" + this.milliseconds;
    },
    '%w': function() {
      return "" + this.day;
    },
    '%y': function() {
      return ("" + this.year).slice(-2);
    },
    '%Y': function() {
      return "" + this.year;
    },
    '%x': function() {
      return this.toLocaleDateString();
    },
    '%X': function() {
      return this.toLocaleTimeString();
    },
    '%z': function() {
      var pfx, tz;
      pfx = this.timezone >= 0 ? '+' : '-';
      tz = Math.abs(this.timezone);
      return "" + pfx + (TzTime.utils.pad(~~(tz / 60), 2)) + (TzTime.utils.pad(tz % 60, 2));
    },
    '%%': function() {
      return '%';
    },
    '%U': function() {
      return '';
    },
    '%Z': function() {
      return '';
    }
  };
  TzTime.PARSE_RECIPES = {
    '%b': function() {
      return {
        re: "" + (TzTime.MNTH.join('|')),
        fn: function(s, meta) {
          var mlc, mo;
          mlc = (function() {
            var _i, _len, _ref, _results;
            _ref = TzTime.MNTH;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              mo = _ref[_i];
              _results.push(mo.toLowerCase());
            }
            return _results;
          })();
          return meta.month = mlc.indexOf(s.toLowerCase());
        }
      };
    },
    '%B': function() {
      return {
        re: "" + (TzTime.MONTHS.join('|')),
        fn: function(s, meta) {
          var mlc, mo;
          mlc = (function() {
            var _i, _len, _ref, _results;
            _ref = TzTime.MONTHS;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              mo = _ref[_i];
              _results.push(mo.toLowerCase());
            }
            return _results;
          })();
          return meta.month = mlc.indexOf(s.toLowerCase());
        }
      };
    },
    '%d': function() {
      return {
        re: '[0-2][0-9]|3[01]',
        fn: function(s, meta) {
          return meta.date = parseInt(s, 10);
        }
      };
    },
    '%D': function() {
      return {
        re: '3[01]|[12]?\\d',
        fn: function(s, meta) {
          return meta.date = parseInt(s, 10);
        }
      };
    },
    '%f': function() {
      return {
        re: '\\d{2}\\.\\d{2}',
        fn: function(s, meta) {
          s = parseFloat(s);
          meta.second = ~~s;
          return meta.millisecond = (s - ~~s) * 1000;
        }
      };
    },
    '%H': function() {
      return {
        re: '[0-1]\\d|2[0-3]',
        fn: function(s, meta) {
          return meta.hour = parseInt(s, 10);
        }
      };
    },
    '%i': function() {
      return {
        re: '1[0-2]|\\d',
        fn: function(s, meta) {
          return meta.hour = parseInt(s, 10);
        }
      };
    },
    '%I': function() {
      return {
        re: '0\\d|1[0-2]',
        fn: function(s, meta) {
          return meta.hour = parseInt(s, 10);
        }
      };
    },
    '%m': function() {
      return {
        re: '0\\d|1[0-2]',
        fn: function(s, meta) {
          return meta.month = parseInt(s, 10) - 1;
        }
      };
    },
    '%M': function() {
      return {
        re: '[0-5]\\d',
        fn: function(s, meta) {
          return meta.minute = parseInt(s, 10);
        }
      };
    },
    '%n': function() {
      return {
        re: '1[0-2]|\\d',
        fn: function(s, meta) {
          return meta.month = parseInt(s, 10) - 1;
        }
      };
    },
    '%N': function() {
      return {
        re: '[1-5]?\\d',
        fn: function(s, meta) {
          return meta.minute = parseInt(s, 10);
        }
      };
    },
    '%p': function() {
      return {
        re: "" + (TzTime.PM.replace(/\./g, '\\.')) + "|" + (TzTime.AM.replace(/\./g, '\\.')),
        fn: function(s, meta) {
          return meta.timeAdjust = TzTime.PM.toLowerCase() === s.toLowerCase();
        }
      };
    },
    '%s': function() {
      return {
        re: '[1-5]?\\d',
        fn: function(s, meta) {
          return meta.second = parseInt(s, 10);
        }
      };
    },
    '%S': function() {
      return {
        re: '[0-5]\\d',
        fn: function(s, meta) {
          return meta.second = parseInt(s, 10);
        }
      };
    },
    '%r': function() {
      return {
        re: '\\d{1,3}',
        fn: function(s, meta) {
          return meta.millisecond = parseInt(s, 10);
        }
      };
    },
    '%y': function() {
      return {
        re: '\\d{2}',
        fn: function(s, meta) {
          var c;
          c = (new Date()).getFullYear().toString().slice(0, 2);
          return meta.year = parseInt(c + s, 10);
        }
      };
    },
    '%Y': function() {
      return {
        re: '\\d{4}',
        fn: function(s, meta) {
          return meta.year = parseInt(s, 10);
        }
      };
    },
    '%z': function() {
      return {
        re: '[+-](?1[01]|0\\d)[0-5]\\d|Z',
        fn: function(s, meta) {
          var h, m, mult;
          if (s === 'Z') {
            return meta.timezone = 0;
          } else {
            mult = s[0] === '-' ? 1 : -1;
            h = parseInt(s.slice(1, 3), 10);
            m = parseInt(s.slice(3, 5), 10);
            return meta.timezone = -mult * (h * 60) + m;
          }
        }
      };
    }
  };
  TzTime.DEFAULT_FORMAT = '%Y-%m-%dT%H:%M:%f%z';
  TzTime.utils = {
    repeat: function(s, count) {
      return new Array(count + 1).join(s);
    },
    reverse: function(s) {
      return s.split('').reverse().join('');
    },
    pad: function(i, digits, tail) {
      var h, t, _ref;
      if (digits == null) {
        digits = 3;
      }
      if (tail == null) {
        tail = false;
      }
      if (tail === false) {
        return (TzTime.utils.repeat('0', digits) + i).slice(-digits);
      } else {
        _ref = i.toString().split('.'), h = _ref[0], t = _ref[1];
        if (tail === 0) {
          return TzTime.utils.pad(h, digits, false);
        } else {
          t || (t = '0');
          h = TzTime.utils.pad(h, digits, false);
          t = TzTime.utils.pad(TzTime.utils.reverse(t), tail, false);
          t = TzTime.utils.reverse(t);
          return [h, t].join('.');
        }
      }
    },
    cycle: function(i, max, zeroIndex) {
      if (zeroIndex == null) {
        zeroIndex = false;
      }
      return i % max || (zeroIndex ? 0 : max);
    },
    hour24: function(h, pm) {
      if (pm == null) {
        pm = false;
      }
      h += (pm ? 12 : 0);
      if (h === 12) {
        return 0;
      }
      if (h === 24) {
        return 12;
      }
      return h;
    }
  };
  return TzTime;
});
